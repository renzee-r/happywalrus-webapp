{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst child_process_1 = require(\"child_process\");\n\nconst os_1 = require(\"os\");\n\nconst path_1 = require(\"path\");\n\nconst fs_1 = require(\"fs\");\n\nconst util_1 = require(\"util\");\n\nfunction toArray(source) {\n  if (typeof source === 'undefined' || source === null) {\n    return [];\n  } else if (!Array.isArray(source)) {\n    return [source];\n  }\n\n  return source;\n}\n/**\r\n * adds arguments as properties to obj\r\n */\n\n\nfunction extend(obj, ...args) {\n  Array.prototype.slice.call(arguments, 1).forEach(function (source) {\n    if (source) {\n      for (let key in source) {\n        obj[key] = source[key];\n      }\n    }\n  });\n  return obj;\n}\n/**\r\n * gets a random int from 0-10000000000\r\n */\n\n\nfunction getRandomInt() {\n  return Math.floor(Math.random() * 10000000000);\n}\n\nclass PythonShellError extends Error {}\n\nexports.PythonShellError = PythonShellError;\n/**\r\n * An interactive Python shell exchanging data through stdio\r\n * @param {string} script    The python script to execute\r\n * @param {object} [options] The launch options (also passed to child_process.spawn)\r\n * @constructor\r\n */\n\nclass PythonShell extends events_1.EventEmitter {\n  /**\r\n   * spawns a python process\r\n   * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified\r\n   * @param options\r\n   */\n  constructor(scriptPath, options) {\n    super();\n    /**\r\n     * returns either pythonshell func (if val string) or custom func (if val Function)\r\n     */\n\n    function resolve(type, val) {\n      if (typeof val === 'string') {\n        // use a built-in function using its name\n        return PythonShell[type][val];\n      } else if (typeof val === 'function') {\n        // use a custom function\n        return val;\n      }\n    }\n\n    if (scriptPath.trim().length == 0) throw Error(\"scriptPath cannot be empty! You must give a script for python to run\");\n    let self = this;\n    let errorData = '';\n    events_1.EventEmitter.call(this);\n    options = extend({}, PythonShell.defaultOptions, options);\n    let pythonPath;\n\n    if (!options.pythonPath) {\n      pythonPath = PythonShell.defaultPythonPath;\n    } else pythonPath = options.pythonPath;\n\n    let pythonOptions = toArray(options.pythonOptions);\n    let scriptArgs = toArray(options.args);\n    this.scriptPath = path_1.join(options.scriptPath || '', scriptPath);\n    this.command = pythonOptions.concat(this.scriptPath, scriptArgs);\n    this.mode = options.mode || 'text';\n    this.formatter = resolve('format', options.formatter || this.mode);\n    this.parser = resolve('parse', options.parser || this.mode);\n    this.stderrParser = resolve('parse', options.stderrParser || this.mode);\n    this.terminated = false;\n    this.childProcess = child_process_1.spawn(pythonPath, this.command, options);\n    ['stdout', 'stdin', 'stderr'].forEach(function (name) {\n      self[name] = self.childProcess[name];\n      self.parser && self[name] && self[name].setEncoding(options.encoding || 'utf8');\n    }); // parse incoming data on stdout\n\n    if (this.parser && this.stdout) {\n      this.stdout.on('data', this.receive.bind(this));\n    } // listen to stderr and emit errors for incoming data\n\n\n    if (this.stderr) {\n      this.stderr.on('data', function (data) {\n        errorData += '' + data;\n        self.receiveStderr(data);\n      });\n      this.stderr.on('end', function () {\n        self.stderrHasEnded = true;\n        terminateIfNeeded();\n      });\n    } else {\n      self.stderrHasEnded = true;\n    }\n\n    if (this.stdout) {\n      this.stdout.on('end', function () {\n        self.stdoutHasEnded = true;\n        terminateIfNeeded();\n      });\n    } else {\n      self.stdoutHasEnded = true;\n    }\n\n    this.childProcess.on('exit', function (code, signal) {\n      self.exitCode = code;\n      self.exitSignal = signal;\n      terminateIfNeeded();\n    });\n\n    function terminateIfNeeded() {\n      if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null && self.exitSignal == null) return;\n      let err;\n\n      if (self.exitCode && self.exitCode !== 0) {\n        if (errorData) {\n          err = self.parseError(errorData);\n        } else {\n          err = new PythonShellError('process exited with code ' + self.exitCode);\n        }\n\n        err = extend(err, {\n          executable: pythonPath,\n          options: pythonOptions.length ? pythonOptions : null,\n          script: self.scriptPath,\n          args: scriptArgs.length ? scriptArgs : null,\n          exitCode: self.exitCode\n        }); // do not emit error if only a callback is used\n\n        if (self.listeners('error').length || !self._endCallback) {\n          self.emit('error', err);\n        }\n      }\n\n      self.terminated = true;\n      self.emit('close');\n      self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);\n    }\n\n    ;\n  }\n  /**\r\n   * checks syntax without executing code\r\n   * @param {string} code\r\n   * @returns {Promise} rejects w/ stderr if syntax failure\r\n   */\n\n\n  static checkSyntax(code) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const randomInt = getRandomInt();\n      const filePath = os_1.tmpdir() + path_1.sep + \"pythonShellSyntaxCheck\".concat(randomInt, \".py\"); // todo: replace this with util.promisify (once we no longer support node v7)\n\n      return new Promise((resolve, reject) => {\n        fs_1.writeFile(filePath, code, err => {\n          if (err) reject(err);\n          resolve(this.checkSyntaxFile(filePath));\n        });\n      });\n    });\n  }\n\n  static getPythonPath() {\n    return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;\n  }\n  /**\r\n   * checks syntax without executing code\r\n   * @param {string} filePath\r\n   * @returns {Promise} rejects w/ stderr if syntax failure\r\n   */\n\n\n  static checkSyntaxFile(filePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const pythonPath = this.getPythonPath();\n      const compileCommand = \"\".concat(pythonPath, \" -m py_compile \").concat(filePath);\n      return new Promise((resolve, reject) => {\n        child_process_1.exec(compileCommand, (error, stdout, stderr) => {\n          if (error == null) resolve();else reject(stderr);\n        });\n      });\n    });\n  }\n  /**\r\n   * Runs a Python script and returns collected messages\r\n   * @param  {string}   scriptPath   The path to the script to execute\r\n   * @param  {Options}   options  The execution options\r\n   * @param  {Function} callback The callback function to invoke with the script results\r\n   * @return {PythonShell}       The PythonShell instance\r\n   */\n\n\n  static run(scriptPath, options, callback) {\n    let pyshell = new PythonShell(scriptPath, options);\n    let output = [];\n    return pyshell.on('message', function (message) {\n      output.push(message);\n    }).end(function (err) {\n      if (err) return callback(err);\n      return callback(null, output.length ? output : null);\n    });\n  }\n\n  /**\r\n   * Runs the inputted string of python code and returns collected messages. DO NOT ALLOW UNTRUSTED USER INPUT HERE!\r\n   * @param  {string}   code   The python code to execute\r\n   * @param  {Options}   options  The execution options\r\n   * @param  {Function} callback The callback function to invoke with the script results\r\n   * @return {PythonShell}       The PythonShell instance\r\n   */\n  static runString(code, options, callback) {\n    // put code in temp file\n    const randomInt = getRandomInt();\n    const filePath = os_1.tmpdir + path_1.sep + \"pythonShellFile\".concat(randomInt, \".py\");\n    fs_1.writeFileSync(filePath, code);\n    return PythonShell.run(filePath, options, callback);\n  }\n\n  static getVersion(pythonPath) {\n    if (!pythonPath) pythonPath = this.getPythonPath();\n    const execPromise = util_1.promisify(child_process_1.exec);\n    return execPromise(pythonPath + \" --version\");\n  }\n\n  static getVersionSync(pythonPath) {\n    if (!pythonPath) pythonPath = this.getPythonPath();\n    return child_process_1.execSync(pythonPath + \" --version\").toString();\n  }\n  /**\r\n   * Parses an error thrown from the Python process through stderr\r\n   * @param  {string|Buffer} data The stderr contents to parse\r\n   * @return {Error} The parsed error with extended stack trace when traceback is available\r\n   */\n\n\n  parseError(data) {\n    let text = '' + data;\n    let error;\n\n    if (/^Traceback/.test(text)) {\n      // traceback data is available\n      let lines = ('' + data).trim().split(new RegExp(os_1.EOL, 'g'));\n      let exception = lines.pop();\n      error = new PythonShellError(exception);\n      error.traceback = data; // extend stack trace\n\n      error.stack += os_1.EOL + '    ----- Python Traceback -----' + os_1.EOL + '  ';\n      error.stack += lines.slice(1).join(os_1.EOL + '  ');\n    } else {\n      // otherwise, create a simpler error with stderr contents\n      error = new PythonShellError(text);\n    }\n\n    return error;\n  }\n\n  /**\r\n   * Sends a message to the Python shell through stdin\r\n   * Override this method to format data to be sent to the Python process\r\n   * @param {string|Object} data The message to send\r\n   * @returns {PythonShell} The same instance for chaining calls\r\n   */\n  send(message) {\n    if (!this.stdin) throw new Error(\"stdin not open for writting\");\n    let data = this.formatter ? this.formatter(message) : message;\n    if (this.mode !== 'binary') data += os_1.EOL;\n    this.stdin.write(data);\n    return this;\n  }\n\n  /**\r\n   * Parses data received from the Python shell stdout stream and emits \"message\" events\r\n   * This method is not used in binary mode\r\n   * Override this method to parse incoming data from the Python process into messages\r\n   * @param {string|Buffer} data The data to parse into messages\r\n   */\n  receive(data) {\n    return this.receiveInternal(data, 'message');\n  }\n\n  /**\r\n   * Parses data received from the Python shell stderr stream and emits \"stderr\" events\r\n   * This method is not used in binary mode\r\n   * Override this method to parse incoming logs from the Python process into messages\r\n   * @param {string|Buffer} data The data to parse into messages\r\n   */\n  receiveStderr(data) {\n    return this.receiveInternal(data, 'stderr');\n  }\n\n  receiveInternal(data, emitType) {\n    let self = this;\n    let parts = ('' + data).split(new RegExp(os_1.EOL, 'g'));\n\n    if (parts.length === 1) {\n      // an incomplete record, keep buffering\n      this._remaining = (this._remaining || '') + parts[0];\n      return this;\n    }\n\n    let lastLine = parts.pop(); // fix the first line with the remaining from the previous iteration of 'receive'\n\n    parts[0] = (this._remaining || '') + parts[0]; // keep the remaining for the next iteration of 'receive'\n\n    this._remaining = lastLine;\n    parts.forEach(function (part) {\n      if (emitType == 'message') self.emit(emitType, self.parser(part));else if (emitType == 'stderr') self.emit(emitType, self.stderrParser(part));\n    });\n    return this;\n  }\n  /**\r\n   * Closes the stdin stream, which should cause the process to finish its work and close\r\n   * @returns {PythonShell} The same instance for chaining calls\r\n   */\n\n\n  end(callback) {\n    if (this.childProcess.stdin) {\n      this.childProcess.stdin.end();\n    }\n\n    this._endCallback = callback;\n    return this;\n  }\n\n  /**\r\n   * Closes the stdin stream, which should cause the process to finish its work and close\r\n   * @returns {PythonShell} The same instance for chaining calls\r\n   */\n  terminate(signal) {\n    this.childProcess.kill(signal);\n    this.terminated = true;\n    return this;\n  }\n\n} // starting 2020 python2 is deprecated so we choose 3 as default\n\n\nPythonShell.defaultPythonPath = process.platform != \"win32\" ? \"python3\" : \"py\";\nPythonShell.defaultOptions = {}; //allow global overrides for options\n// built-in formatters\n\nPythonShell.format = {\n  text: function toText(data) {\n    if (!data) return '';else if (typeof data !== 'string') return data.toString();\n    return data;\n  },\n  json: function toJson(data) {\n    return JSON.stringify(data);\n  }\n}; //built-in parsers\n\nPythonShell.parse = {\n  text: function asText(data) {\n    return data;\n  },\n  json: function asJson(data) {\n    return JSON.parse(data);\n  }\n};\nexports.PythonShell = PythonShell;\n;","map":null,"metadata":{},"sourceType":"script"}